{"version":3,"sources":["gridList.js"],"names":[],"mappings":"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","file":"gridList-compiled.js","sourcesContent":["/*!\n * Angular Material Design\n * https://github.com/angular/material\n * @license MIT\n * v1.1.1-master-f7ecb4f\n */\n(function( window, angular, undefined ){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.gridList\n */\nGridListController['$inject'] = [\"$mdUtil\"];\nGridLayoutFactory['$inject'] = [\"$mdUtil\"];\nGridListDirective['$inject'] = [\"$interpolate\", \"$mdConstant\", \"$mdGridLayout\", \"$mdMedia\"];\nGridTileDirective['$inject'] = [\"$mdMedia\"];\nangular.module('material.components.gridList', ['material.core'])\n       .directive('mdGridList', GridListDirective)\n       .directive('mdGridTile', GridTileDirective)\n       .directive('mdGridTileFooter', GridTileCaptionDirective)\n       .directive('mdGridTileHeader', GridTileCaptionDirective)\n       .factory('$mdGridLayout', GridLayoutFactory);\n\n/**\n * @ngdoc directive\n * @name mdGridList\n * @module material.components.gridList\n * @restrict E\n * @description\n * Grid lists are an alternative to standard list views. Grid lists are distinct\n * from grids used for layouts and other visual presentations.\n *\n * A grid list is best suited to presenting a homogenous data type, typically\n * images, and is optimized for visual comprehension and differentiating between\n * like data types.\n *\n * A grid list is a continuous element consisting of tessellated, regular\n * subdivisions called cells that contain tiles (`md-grid-tile`).\n *\n * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png\"\n *    style=\"width: 300px; height: auto; margin-right: 16px;\" alt=\"Concept of grid explained visually\">\n * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png\"\n *    style=\"width: 300px; height: auto;\" alt=\"Grid concepts legend\">\n *\n * Cells are arrayed vertically and horizontally within the grid.\n *\n * Tiles hold content and can span one or more cells vertically or horizontally.\n *\n * ### Responsive Attributes\n *\n * The `md-grid-list` directive supports \"responsive\" attributes, which allow\n * different `md-cols`, `md-gutter` and `md-row-height` values depending on the\n * currently matching media query.\n *\n * In order to set a responsive attribute, first define the fallback value with\n * the standard attribute name, then add additional attributes with the\n * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n * (ie. `md-cols-lg=\"8\"`)\n *\n * @param {number} md-cols Number of columns in the grid.\n * @param {string} md-row-height One of\n * <ul>\n *   <li>CSS length - Fixed height rows (eg. `8px` or `1rem`)</li>\n *   <li>`{width}:{height}` - Ratio of width to height (eg.\n *   `md-row-height=\"16:9\"`)</li>\n *   <li>`\"fit\"` - Height will be determined by subdividing the available\n *   height by the number of rows</li>\n * </ul>\n * @param {string=} md-gutter The amount of space between tiles in CSS units\n *     (default 1px)\n * @param {expression=} md-on-layout Expression to evaluate after layout. Event\n *     object is available as `$event`, and contains performance information.\n *\n * @usage\n * Basic:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"5\" md-gutter=\"1em\" md-row-height=\"4:3\">\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Fixed-height rows:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"4\" md-row-height=\"200px\" ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Fit rows:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"4\" md-row-height=\"fit\" style=\"height: 400px;\" ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Using responsive attributes:\n * <hljs lang=\"html\">\n * <md-grid-list\n *     md-cols-sm=\"2\"\n *     md-cols-md=\"4\"\n *     md-cols-lg=\"8\"\n *     md-cols-gt-lg=\"12\"\n *     ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n */\nfunction GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {\n  return {\n    restrict: 'E',\n    controller: GridListController,\n    scope: {\n      mdOnLayout: '&'\n    },\n    link: postLink\n  };\n\n  function postLink(scope, element, attrs, ctrl) {\n    element.addClass('_md');     // private md component indicator for styling\n    \n    // Apply semantics\n    element.attr('role', 'list');\n\n    // Provide the controller with a way to trigger layouts.\n    ctrl.layoutDelegate = layoutDelegate;\n\n    var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),\n        unwatchAttrs = watchMedia();\n      scope.$on('$destroy', unwatchMedia);\n\n    /**\n     * Watches for changes in media, invalidating layout as necessary.\n     */\n    function watchMedia() {\n      for (var mediaName in $mdConstant.MEDIA) {\n        $mdMedia(mediaName); // initialize\n        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n            .addListener(invalidateLayout);\n      }\n      return $mdMedia.watchResponsiveAttributes(\n          ['md-cols', 'md-row-height', 'md-gutter'], attrs, layoutIfMediaMatch);\n    }\n\n    function unwatchMedia() {\n      ctrl.layoutDelegate = angular.noop;\n\n      unwatchAttrs();\n      for (var mediaName in $mdConstant.MEDIA) {\n        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n            .removeListener(invalidateLayout);\n      }\n    }\n\n    /**\n     * Performs grid layout if the provided mediaName matches the currently\n     * active media type.\n     */\n    function layoutIfMediaMatch(mediaName) {\n      if (mediaName == null) {\n        // TODO(shyndman): It would be nice to only layout if we have\n        // instances of attributes using this media type\n        ctrl.invalidateLayout();\n      } else if ($mdMedia(mediaName)) {\n        ctrl.invalidateLayout();\n      }\n    }\n\n    var lastLayoutProps;\n\n    /**\n     * Invokes the layout engine, and uses its results to lay out our\n     * tile elements.\n     *\n     * @param {boolean} tilesInvalidated Whether tiles have been\n     *    added/removed/moved since the last layout. This is to avoid situations\n     *    where tiles are replaced with properties identical to their removed\n     *    counterparts.\n     */\n    function layoutDelegate(tilesInvalidated) {\n      var tiles = getTileElements();\n      var props = {\n        tileSpans: getTileSpans(tiles),\n        colCount: getColumnCount(),\n        rowMode: getRowMode(),\n        rowHeight: getRowHeight(),\n        gutter: getGutter()\n      };\n\n      if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {\n        return;\n      }\n\n      var performance =\n        $mdGridLayout(props.colCount, props.tileSpans, tiles)\n          .map(function(tilePositions, rowCount) {\n            return {\n              grid: {\n                element: element,\n                style: getGridStyle(props.colCount, rowCount,\n                    props.gutter, props.rowMode, props.rowHeight)\n              },\n              tiles: tilePositions.map(function(ps, i) {\n                return {\n                  element: angular.element(tiles[i]),\n                  style: getTileStyle(ps.position, ps.spans,\n                      props.colCount, rowCount,\n                      props.gutter, props.rowMode, props.rowHeight)\n                }\n              })\n            }\n          })\n          .reflow()\n          .performance();\n\n      // Report layout\n      scope.mdOnLayout({\n        $event: {\n          performance: performance\n        }\n      });\n\n      lastLayoutProps = props;\n    }\n\n    // Use $interpolate to do some simple string interpolation as a convenience.\n\n    var startSymbol = $interpolate.startSymbol();\n    var endSymbol = $interpolate.endSymbol();\n\n    // Returns an expression wrapped in the interpolator's start and end symbols.\n    function expr(exprStr) {\n      return startSymbol + exprStr + endSymbol;\n    }\n\n    // The amount of space a single 1x1 tile would take up (either width or height), used as\n    // a basis for other calculations. This consists of taking the base size percent (as would be\n    // if evenly dividing the size between cells), and then subtracting the size of one gutter.\n    // However, since there are no gutters on the edges, each tile only uses a fration\n    // (gutterShare = numGutters / numCells) of the gutter size. (Imagine having one gutter per\n    // tile, and then breaking up the extra gutter on the edge evenly among the cells).\n    var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');\n\n    // The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.\n    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\n    // row/column (offset).\n    var POSITION  = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');\n\n    // The actual size of a tile, e.g., width or height, taking rowSpan or colSpan into account.\n    // This is computed by multiplying the base unit by the rowSpan/colSpan, and then adding back\n    // in the space that the gutter would normally have used (which was already accounted for in\n    // the base unit calculation).\n    var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');\n\n    /**\n     * Gets the styles applied to a tile element described by the given parameters.\n     * @param {{row: number, col: number}} position The row and column indices of the tile.\n     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.\n     * @param {number} colCount The number of columns.\n     * @param {number} rowCount The number of rows.\n     * @param {string} gutter The amount of space between tiles. This will be something like\n     *     '5px' or '2em'.\n     * @param {string} rowMode The row height mode. Can be one of:\n     *     'fixed': all rows have a fixed size, given by rowHeight,\n     *     'ratio': row height defined as a ratio to width, or\n     *     'fit': fit to the grid-list element height, divinding evenly among rows.\n     * @param {string|number} rowHeight The height of a row. This is only used for 'fixed' mode and\n     *     for 'ratio' mode. For 'ratio' mode, this is the *ratio* of width-to-height (e.g., 0.75).\n     * @returns {Object} Map of CSS properties to be applied to the style element. Will define\n     *     values for top, left, width, height, marginTop, and paddingTop.\n     */\n    function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {\n      // TODO(shyndman): There are style caching opportunities here.\n\n      // Percent of the available horizontal space that one column takes up.\n      var hShare = (1 / colCount) * 100;\n\n      // Fraction of the gutter size that each column takes up.\n      var hGutterShare = (colCount - 1) / colCount;\n\n      // Base horizontal size of a column.\n      var hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter});\n\n      // The width and horizontal position of each tile is always calculated the same way, but the\n      // height and vertical position depends on the rowMode.\n      var style = {\n        left: POSITION({ unit: hUnit, offset: position.col, gutter: gutter }),\n        width: DIMENSION({ unit: hUnit, span: spans.col, gutter: gutter }),\n        // resets\n        paddingTop: '',\n        marginTop: '',\n        top: '',\n        height: ''\n      };\n\n      switch (rowMode) {\n        case 'fixed':\n          // In fixed mode, simply use the given rowHeight.\n          style.top = POSITION({ unit: rowHeight, offset: position.row, gutter: gutter });\n          style.height = DIMENSION({ unit: rowHeight, span: spans.row, gutter: gutter });\n          break;\n\n        case 'ratio':\n          // Percent of the available vertical space that one row takes up. Here, rowHeight holds\n          // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.\n          var vShare = hShare / rowHeight;\n\n          // Base veritcal size of a row.\n          var vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\n          // padidngTop and marginTop are used to maintain the given aspect ratio, as\n          // a percentage-based value for these properties is applied to the *width* of the\n          // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\n          style.paddingTop = DIMENSION({ unit: vUnit, span: spans.row, gutter: gutter});\n          style.marginTop = POSITION({ unit: vUnit, offset: position.row, gutter: gutter });\n          break;\n\n        case 'fit':\n          // Fraction of the gutter size that each column takes up.\n          var vGutterShare = (rowCount - 1) / rowCount;\n\n          // Percent of the available vertical space that one row takes up.\n          var vShare = (1 / rowCount) * 100;\n\n          // Base vertical size of a row.\n          var vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter});\n\n          style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter});\n          style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});\n          break;\n      }\n\n      return style;\n    }\n\n    function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {\n      var style = {};\n\n      switch(rowMode) {\n        case 'fixed':\n          style.height = DIMENSION({ unit: rowHeight, span: rowCount, gutter: gutter });\n          style.paddingBottom = '';\n          break;\n\n        case 'ratio':\n          // rowHeight is width / height\n          var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,\n              hShare = (1 / colCount) * 100,\n              vShare = hShare * (1 / rowHeight),\n              vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\n          style.height = '';\n          style.paddingBottom = DIMENSION({ unit: vUnit, span: rowCount, gutter: gutter});\n          break;\n\n        case 'fit':\n          // noop, as the height is user set\n          break;\n      }\n\n      return style;\n    }\n\n    function getTileElements() {\n      return [].filter.call(element.children(), function(ele) {\n        return ele.tagName == 'MD-GRID-TILE' && !ele.$$mdDestroyed;\n      });\n    }\n\n    /**\n     * Gets an array of objects containing the rowspan and colspan for each tile.\n     * @returns {Array<{row: number, col: number}>}\n     */\n    function getTileSpans(tileElements) {\n      return [].map.call(tileElements, function(ele) {\n        var ctrl = angular.element(ele).controller('mdGridTile');\n        return {\n          row: parseInt(\n              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,\n          col: parseInt(\n              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1\n        };\n      });\n    }\n\n    function getColumnCount() {\n      var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);\n      if (isNaN(colCount)) {\n        throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';\n      }\n      return colCount;\n    }\n\n    function getGutter() {\n      return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);\n    }\n\n    function getRowHeight() {\n      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n      if (!rowHeight) {\n        throw 'md-grid-list: md-row-height attribute was not found';\n      }\n\n      switch (getRowMode()) {\n        case 'fixed':\n          return applyDefaultUnit(rowHeight);\n        case 'ratio':\n          var whRatio = rowHeight.split(':');\n          return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);\n        case 'fit':\n          return 0; // N/A\n      }\n    }\n\n    function getRowMode() {\n      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n      if (!rowHeight) {\n        throw 'md-grid-list: md-row-height attribute was not found';\n      }\n\n      if (rowHeight == 'fit') {\n        return 'fit';\n      } else if (rowHeight.indexOf(':') !== -1) {\n        return 'ratio';\n      } else {\n        return 'fixed';\n      }\n    }\n\n    function applyDefaultUnit(val) {\n      return /\\D$/.test(val) ? val : val + 'px';\n    }\n  }\n}\n\n/* ngInject */\nfunction GridListController($mdUtil) {\n  this.layoutInvalidated = false;\n  this.tilesInvalidated = false;\n  this.$timeout_ = $mdUtil.nextTick;\n  this.layoutDelegate = angular.noop;\n}\n\nGridListController.prototype = {\n  invalidateTiles: function() {\n    this.tilesInvalidated = true;\n    this.invalidateLayout();\n  },\n\n  invalidateLayout: function() {\n    if (this.layoutInvalidated) {\n      return;\n    }\n    this.layoutInvalidated = true;\n    this.$timeout_(angular.bind(this, this.layout));\n  },\n\n  layout: function() {\n    try {\n      this.layoutDelegate(this.tilesInvalidated);\n    } finally {\n      this.layoutInvalidated = false;\n      this.tilesInvalidated = false;\n    }\n  }\n};\n\n\n/* ngInject */\nfunction GridLayoutFactory($mdUtil) {\n  var defaultAnimator = GridTileAnimator;\n\n  /**\n   * Set the reflow animator callback\n   */\n  GridLayout.animateWith = function(customAnimator) {\n    defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;\n  };\n\n  return GridLayout;\n\n  /**\n   * Publish layout function\n   */\n  function GridLayout(colCount, tileSpans) {\n      var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;\n\n      layoutTime = $mdUtil.time(function() {\n        layoutInfo = calculateGridFor(colCount, tileSpans);\n      });\n\n      return self = {\n\n        /**\n         * An array of objects describing each tile's position in the grid.\n         */\n        layoutInfo: function() {\n          return layoutInfo;\n        },\n\n        /**\n         * Maps grid positioning to an element and a set of styles using the\n         * provided updateFn.\n         */\n        map: function(updateFn) {\n          mapTime = $mdUtil.time(function() {\n            var info = self.layoutInfo();\n            gridStyles = updateFn(info.positioning, info.rowCount);\n          });\n          return self;\n        },\n\n        /**\n         * Default animator simply sets the element.css( <styles> ). An alternate\n         * animator can be provided as an argument. The function has the following\n         * signature:\n         *\n         *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)\n         */\n        reflow: function(animatorFn) {\n          reflowTime = $mdUtil.time(function() {\n            var animator = animatorFn || defaultAnimator;\n            animator(gridStyles.grid, gridStyles.tiles);\n          });\n          return self;\n        },\n\n        /**\n         * Timing for the most recent layout run.\n         */\n        performance: function() {\n          return {\n            tileCount: tileSpans.length,\n            layoutTime: layoutTime,\n            mapTime: mapTime,\n            reflowTime: reflowTime,\n            totalTime: layoutTime + mapTime + reflowTime\n          };\n        }\n      };\n    }\n\n  /**\n   * Default Gridlist animator simple sets the css for each element;\n   * NOTE: any transitions effects must be manually set in the CSS.\n   * e.g.\n   *\n   *  md-grid-tile {\n   *    transition: all 700ms ease-out 50ms;\n   *  }\n   *\n   */\n  function GridTileAnimator(grid, tiles) {\n    grid.element.css(grid.style);\n    tiles.forEach(function(t) {\n      t.element.css(t.style);\n    })\n  }\n\n  /**\n   * Calculates the positions of tiles.\n   *\n   * The algorithm works as follows:\n   *    An Array<Number> with length colCount (spaceTracker) keeps track of\n   *    available tiling positions, where elements of value 0 represents an\n   *    empty position. Space for a tile is reserved by finding a sequence of\n   *    0s with length <= than the tile's colspan. When such a space has been\n   *    found, the occupied tile positions are incremented by the tile's\n   *    rowspan value, as these positions have become unavailable for that\n   *    many rows.\n   *\n   *    If the end of a row has been reached without finding space for the\n   *    tile, spaceTracker's elements are each decremented by 1 to a minimum\n   *    of 0. Rows are searched in this fashion until space is found.\n   */\n  function calculateGridFor(colCount, tileSpans) {\n    var curCol = 0,\n        curRow = 0,\n        spaceTracker = newSpaceTracker();\n\n    return {\n      positioning: tileSpans.map(function(spans, i) {\n        return {\n          spans: spans,\n          position: reserveSpace(spans, i)\n        };\n      }),\n      rowCount: curRow + Math.max.apply(Math, spaceTracker)\n    };\n\n    function reserveSpace(spans, i) {\n      if (spans.col > colCount) {\n        throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' +\n            '(' + spans.col + ') that exceeds the column count ' +\n            '(' + colCount + ')';\n      }\n\n      var start = 0,\n          end = 0;\n\n      // TODO(shyndman): This loop isn't strictly necessary if you can\n      // determine the minimum number of rows before a space opens up. To do\n      // this, recognize that you've iterated across an entire row looking for\n      // space, and if so fast-forward by the minimum rowSpan count. Repeat\n      // until the required space opens up.\n      while (end - start < spans.col) {\n        if (curCol >= colCount) {\n          nextRow();\n          continue;\n        }\n\n        start = spaceTracker.indexOf(0, curCol);\n        if (start === -1 || (end = findEnd(start + 1)) === -1) {\n          start = end = 0;\n          nextRow();\n          continue;\n        }\n\n        curCol = end + 1;\n      }\n\n      adjustRow(start, spans.col, spans.row);\n      curCol = start + spans.col;\n\n      return {\n        col: start,\n        row: curRow\n      };\n    }\n\n    function nextRow() {\n      curCol = 0;\n      curRow++;\n      adjustRow(0, colCount, -1); // Decrement row spans by one\n    }\n\n    function adjustRow(from, cols, by) {\n      for (var i = from; i < from + cols; i++) {\n        spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);\n      }\n    }\n\n    function findEnd(start) {\n      var i;\n      for (i = start; i < spaceTracker.length; i++) {\n        if (spaceTracker[i] !== 0) {\n          return i;\n        }\n      }\n\n      if (i === spaceTracker.length) {\n        return i;\n      }\n    }\n\n    function newSpaceTracker() {\n      var tracker = [];\n      for (var i = 0; i < colCount; i++) {\n        tracker.push(0);\n      }\n      return tracker;\n    }\n  }\n}\n\n/**\n * @ngdoc directive\n * @name mdGridTile\n * @module material.components.gridList\n * @restrict E\n * @description\n * Tiles contain the content of an `md-grid-list`. They span one or more grid\n * cells vertically or horizontally, and use `md-grid-tile-{footer,header}` to\n * display secondary content.\n *\n * ### Responsive Attributes\n *\n * The `md-grid-tile` directive supports \"responsive\" attributes, which allow\n * different `md-rowspan` and `md-colspan` values depending on the currently\n * matching media query.\n *\n * In order to set a responsive attribute, first define the fallback value with\n * the standard attribute name, then add additional attributes with the\n * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n * (ie. `md-colspan-sm=\"4\"`)\n *\n * @param {number=} md-colspan The number of columns to span (default 1). Cannot\n *    exceed the number of columns in the grid. Supports interpolation.\n * @param {number=} md-rowspan The number of rows to span (default 1). Supports\n *     interpolation.\n *\n * @usage\n * With header:\n * <hljs lang=\"html\">\n * <md-grid-tile>\n *   <md-grid-tile-header>\n *     <h3>This is a header</h3>\n *   </md-grid-tile-header>\n * </md-grid-tile>\n * </hljs>\n *\n * With footer:\n * <hljs lang=\"html\">\n * <md-grid-tile>\n *   <md-grid-tile-footer>\n *     <h3>This is a footer</h3>\n *   </md-grid-tile-footer>\n * </md-grid-tile>\n * </hljs>\n *\n * Spanning multiple rows/columns:\n * <hljs lang=\"html\">\n * <md-grid-tile md-colspan=\"2\" md-rowspan=\"3\">\n * </md-grid-tile>\n * </hljs>\n *\n * Responsive attributes:\n * <hljs lang=\"html\">\n * <md-grid-tile md-colspan=\"1\" md-colspan-sm=\"3\" md-colspan-md=\"5\">\n * </md-grid-tile>\n * </hljs>\n */\nfunction GridTileDirective($mdMedia) {\n  return {\n    restrict: 'E',\n    require: '^mdGridList',\n    template: '<figure ng-transclude></figure>',\n    transclude: true,\n    scope: {},\n    // Simple controller that exposes attributes to the grid directive\n    controller: [\"$attrs\", function($attrs) {\n      this.$attrs = $attrs;\n    }],\n    link: postLink\n  };\n\n  function postLink(scope, element, attrs, gridCtrl) {\n    // Apply semantics\n    element.attr('role', 'listitem');\n\n    // If our colspan or rowspan changes, trigger a layout\n    var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'],\n        attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));\n\n    // Tile registration/deregistration\n    gridCtrl.invalidateTiles();\n    scope.$on('$destroy', function() {\n      // Mark the tile as destroyed so it is no longer considered in layout,\n      // even if the DOM element sticks around (like during a leave animation)\n      element[0].$$mdDestroyed = true;\n      unwatchAttrs();\n      gridCtrl.invalidateLayout();\n    });\n\n    if (angular.isDefined(scope.$parent.$index)) {\n      scope.$watch(function() { return scope.$parent.$index; },\n        function indexChanged(newIdx, oldIdx) {\n          if (newIdx === oldIdx) {\n            return;\n          }\n          gridCtrl.invalidateTiles();\n        });\n    }\n  }\n}\n\n\nfunction GridTileCaptionDirective() {\n  return {\n    template: '<figcaption ng-transclude></figcaption>',\n    transclude: true\n  };\n}\n\n})(window, window.angular);"]}