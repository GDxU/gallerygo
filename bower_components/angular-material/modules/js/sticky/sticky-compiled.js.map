{"version":3,"sources":["sticky.js"],"names":[],"mappings":"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","file":"sticky-compiled.js","sourcesContent":["/*!\n * Angular Material Design\n * https://github.com/angular/material\n * @license MIT\n * v1.1.1-master-f7ecb4f\n */\n(function( window, angular, undefined ){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.sticky\n * @description\n * Sticky effects for md\n *\n */\nMdSticky['$inject'] = [\"$mdConstant\", \"$$rAF\", \"$mdUtil\", \"$compile\"];\nangular\n  .module('material.components.sticky', [\n    'material.core',\n    'material.components.content'\n  ])\n  .factory('$mdSticky', MdSticky);\n\n/**\n * @ngdoc service\n * @name $mdSticky\n * @module material.components.sticky\n *\n * @description\n * The `$mdSticky`service provides a mixin to make elements sticky.\n *\n * Whenever the current browser supports stickiness natively, the `$mdSticky` service will just\n * use the native browser stickiness.\n *\n * By default the `$mdSticky` service compiles the cloned element, when not specified through the `elementClone`\n * parameter, in the same scope as the actual element lives.\n *\n *\n * <h3>Notes</h3>\n * When using an element which is containing a compiled directive, which changed its DOM structure during compilation,\n * you should compile the clone yourself using the plain template.<br/><br/>\n * See the right usage below:\n * <hljs lang=\"js\">\n *   angular.module('myModule')\n *     .directive('stickySelect', function($mdSticky, $compile) {\n *       var SELECT_TEMPLATE =\n *         '<md-select ng-model=\"selected\">' +\n *           '<md-option>Option 1</md-option>' +\n *         '</md-select>';\n *\n *       return {\n *         restrict: 'E',\n *         replace: true,\n *         template: SELECT_TEMPLATE,\n *         link: function(scope,element) {\n *           $mdSticky(scope, element, $compile(SELECT_TEMPLATE)(scope));\n *         }\n *       };\n *     });\n * </hljs>\n *\n * @usage\n * <hljs lang=\"js\">\n *   angular.module('myModule')\n *     .directive('stickyText', function($mdSticky, $compile) {\n *       return {\n *         restrict: 'E',\n *         template: '<span>Sticky Text</span>',\n *         link: function(scope,element) {\n *           $mdSticky(scope, element);\n *         }\n *       };\n *     });\n * </hljs>\n *\n * @returns A `$mdSticky` function that takes three arguments:\n *   - `scope`\n *   - `element`: The element that will be 'sticky'\n *   - `elementClone`: A clone of the element, that will be shown\n *     when the user starts scrolling past the original element.\n *     If not provided, it will use the result of `element.clone()` and compiles it in the given scope.\n */\nfunction MdSticky($mdConstant, $$rAF, $mdUtil, $compile) {\n\n  var browserStickySupport = $mdUtil.checkStickySupport();\n\n  /**\n   * Registers an element as sticky, used internally by directives to register themselves\n   */\n  return function registerStickyElement(scope, element, stickyClone) {\n    var contentCtrl = element.controller('mdContent');\n    if (!contentCtrl) return;\n\n    if (browserStickySupport) {\n      element.css({\n        position: browserStickySupport,\n        top: 0,\n        'z-index': 2\n      });\n    } else {\n      var $$sticky = contentCtrl.$element.data('$$sticky');\n      if (!$$sticky) {\n        $$sticky = setupSticky(contentCtrl);\n        contentCtrl.$element.data('$$sticky', $$sticky);\n      }\n\n      // Compile our cloned element, when cloned in this service, into the given scope.\n      var cloneElement = stickyClone || $compile(element.clone())(scope);\n\n      var deregister = $$sticky.add(element, cloneElement);\n      scope.$on('$destroy', deregister);\n    }\n  };\n\n  function setupSticky(contentCtrl) {\n    var contentEl = contentCtrl.$element;\n\n    // Refresh elements is very expensive, so we use the debounced\n    // version when possible.\n    var debouncedRefreshElements = $$rAF.throttle(refreshElements);\n\n    // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,\n    // more reliable than `scroll` on android.\n    setupAugmentedScrollEvents(contentEl);\n    contentEl.on('$scrollstart', debouncedRefreshElements);\n    contentEl.on('$scroll', onScroll);\n\n    var self;\n    return self = {\n      prev: null,\n      current: null, //the currently stickied item\n      next: null,\n      items: [],\n      add: add,\n      refreshElements: refreshElements\n    };\n\n    /***************\n     * Public\n     ***************/\n    // Add an element and its sticky clone to this content's sticky collection\n    function add(element, stickyClone) {\n      stickyClone.addClass('md-sticky-clone');\n\n      var item = {\n        element: element,\n        clone: stickyClone\n      };\n      self.items.push(item);\n\n      $mdUtil.nextTick(function() {\n        contentEl.prepend(item.clone);\n      });\n\n      debouncedRefreshElements();\n\n      return function remove() {\n        self.items.forEach(function(item, index) {\n          if (item.element[0] === element[0]) {\n            self.items.splice(index, 1);\n            item.clone.remove();\n          }\n        });\n        debouncedRefreshElements();\n      };\n    }\n\n    function refreshElements() {\n      // Sort our collection of elements by their current position in the DOM.\n      // We need to do this because our elements' order of being added may not\n      // be the same as their order of display.\n      self.items.forEach(refreshPosition);\n      self.items = self.items.sort(function(a, b) {\n        return a.top < b.top ? -1 : 1;\n      });\n\n      // Find which item in the list should be active, \n      // based upon the content's current scroll position\n      var item;\n      var currentScrollTop = contentEl.prop('scrollTop');\n      for (var i = self.items.length - 1; i >= 0; i--) {\n        if (currentScrollTop > self.items[i].top) {\n          item = self.items[i];\n          break;\n        }\n      }\n      setCurrentItem(item);\n    }\n\n    /***************\n     * Private\n     ***************/\n\n    // Find the `top` of an item relative to the content element,\n    // and also the height.\n    function refreshPosition(item) {\n      // Find the top of an item by adding to the offsetHeight until we reach the \n      // content element.\n      var current = item.element[0];\n      item.top = 0;\n      item.left = 0;\n      item.right = 0;\n      while (current && current !== contentEl[0]) {\n        item.top += current.offsetTop;\n        item.left += current.offsetLeft;\n        if ( current.offsetParent ){\n          item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft; //Compute offsetRight\n        }\n        current = current.offsetParent;\n      }\n      item.height = item.element.prop('offsetHeight');\n\n      var defaultVal = $mdUtil.floatingScrollbars() ? '0' : undefined;\n      $mdUtil.bidi(item.clone, 'margin-left', item.left, defaultVal);\n      $mdUtil.bidi(item.clone, 'margin-right', defaultVal, item.right);\n    }\n\n    // As we scroll, push in and select the correct sticky element.\n    function onScroll() {\n      var scrollTop = contentEl.prop('scrollTop');\n      var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);\n\n      // Store the previous scroll so we know which direction we are scrolling\n      onScroll.prevScrollTop = scrollTop;\n\n      //\n      // AT TOP (not scrolling)\n      //\n      if (scrollTop === 0) {\n        // If we're at the top, just clear the current item and return\n        setCurrentItem(null);\n        return;\n      }\n\n      //\n      // SCROLLING DOWN (going towards the next item)\n      //\n      if (isScrollingDown) {\n\n        // If we've scrolled down past the next item's position, sticky it and return\n        if (self.next && self.next.top <= scrollTop) {\n          setCurrentItem(self.next);\n          return;\n        }\n\n        // If the next item is close to the current one, push the current one up out of the way\n        if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {\n          translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));\n          return;\n        }\n      }\n\n      //\n      // SCROLLING UP (not at the top & not scrolling down; must be scrolling up)\n      //\n      if (!isScrollingDown) {\n\n        // If we've scrolled up past the previous item's position, sticky it and return\n        if (self.current && self.prev && scrollTop < self.current.top) {\n          setCurrentItem(self.prev);\n          return;\n        }\n\n        // If the next item is close to the current one, pull the current one down into view\n        if (self.next && self.current && (scrollTop >= (self.next.top - self.current.height))) {\n          translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));\n          return;\n        }\n      }\n\n      //\n      // Otherwise, just move the current item to the proper place (scrolling up or down)\n      //\n      if (self.current) {\n        translate(self.current, scrollTop);\n      }\n    }\n\n    function setCurrentItem(item) {\n      if (self.current === item) return;\n      // Deactivate currently active item\n      if (self.current) {\n        translate(self.current, null);\n        setStickyState(self.current, null);\n      }\n\n      // Activate new item if given\n      if (item) {\n        setStickyState(item, 'active');\n      }\n\n      self.current = item;\n      var index = self.items.indexOf(item);\n      // If index === -1, index + 1 = 0. It works out.\n      self.next = self.items[index + 1];\n      self.prev = self.items[index - 1];\n      setStickyState(self.next, 'next');\n      setStickyState(self.prev, 'prev');\n    }\n\n    function setStickyState(item, state) {\n      if (!item || item.state === state) return;\n      if (item.state) {\n        item.clone.attr('sticky-prev-state', item.state);\n        item.element.attr('sticky-prev-state', item.state);\n      }\n      item.clone.attr('sticky-state', state);\n      item.element.attr('sticky-state', state);\n      item.state = state;\n    }\n\n    function translate(item, amount) {\n      if (!item) return;\n      if (amount === null || amount === undefined) {\n        if (item.translateY) {\n          item.translateY = null;\n          item.clone.css($mdConstant.CSS.TRANSFORM, '');\n        }\n      } else {\n        item.translateY = amount;\n\n        $mdUtil.bidi( item.clone, $mdConstant.CSS.TRANSFORM,\n          'translate3d(' + item.left + 'px,' + amount + 'px,0)',\n          'translateY(' + amount + 'px)'\n        );\n      }\n    }\n  }\n\n\n  // Android 4.4 don't accurately give scroll events.\n  // To fix this problem, we setup a fake scroll event. We say:\n  // > If a scroll or touchmove event has happened in the last DELAY milliseconds, \n  //   then send a `$scroll` event every animationFrame.\n  // Additionally, we add $scrollstart and $scrollend events.\n  function setupAugmentedScrollEvents(element) {\n    var SCROLL_END_DELAY = 200;\n    var isScrolling;\n    var lastScrollTime;\n    element.on('scroll touchmove', function() {\n      if (!isScrolling) {\n        isScrolling = true;\n        $$rAF.throttle(loopScrollEvent);\n        element.triggerHandler('$scrollstart');\n      }\n      element.triggerHandler('$scroll');\n      lastScrollTime = +$mdUtil.now();\n    });\n\n    function loopScrollEvent() {\n      if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {\n        isScrolling = false;\n        element.triggerHandler('$scrollend');\n      } else {\n        element.triggerHandler('$scroll');\n        $$rAF.throttle(loopScrollEvent);\n      }\n    }\n  }\n\n}\n\n})(window, window.angular);"]}