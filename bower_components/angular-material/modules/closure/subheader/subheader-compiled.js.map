{"version":3,"sources":["subheader.js"],"names":[],"mappings":";;AAAA;;;;;;AAMA,KAAK,OAAL,CAAa,iCAAb;AACA,KAAK,OAAL,CAAa,8BAAb;AACA,KAAK,OAAL,CAAa,iBAAb;AACA;;;;;;;;;;;;;;;;;;AAkBA,qBAAqB,SAArB,IAAkC,CAAC,WAAD,EAAc,UAAd,EAA0B,YAA1B,EAAwC,SAAxC,EAAmD,SAAnD,CAAlC;AACA,QACG,MADH,CACU,+BADV,EAC2C,CACvC,eADuC,EAEvC,4BAFuC,CAD3C,EAKG,SALH,CAKa,aALb,EAK4B,oBAL5B;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAAS,oBAAT,CAA8B,SAA9B,EAAyC,QAAzC,EAAmD,UAAnD,EAA+D,OAA/D,EAAwE,OAAxE,EAAiF;AAC/E,SAAO;AACL,cAAU,GADL;AAEL,aAAS,IAFJ;AAGL,gBAAY,IAHP;AAIL,cACA,mCACA,oCADA,GAEA,8CAFA,GAGA,UAHA,GAIA,QATK;AAWL,UAAM,SAAS,QAAT,CAAkB,KAAlB,EAAyB,OAAzB,EAAkC,IAAlC,EAAwC,WAAxC,EAAqD,UAArD,EAAiE;AACrE,iBAAW,OAAX;AACA,cAAQ,QAAR,CAAiB,KAAjB;;AAEA;AACA;AACA,cAAQ,QAAR,GAAmB,eAAnB,CAAmC,OAAnC,EAA4C,WAA5C;;AAEA,UAAI,YAAY,QAAQ,CAAR,EAAW,SAA3B;;AAEA,eAAS,UAAT,CAAoB,EAApB,EAAwB;AACtB,eAAO,QAAQ,OAAR,CAAgB,GAAG,CAAH,EAAM,aAAN,CAAoB,uBAApB,CAAhB,CAAP;AACD;;AAED;AACA;AACA;AACA,WAAK,IAAL,CAAU,MAAV,EAAkB,SAAlB;AACA,cAAQ,MAAR,CAAe,OAAf,EAAwB,YAAxB,EAAsC,GAAtC;;AAEA;AACA;AACA,iBAAW,KAAX,EAAkB,UAAS,KAAT,EAAgB;AAChC,mBAAW,OAAX,EAAoB,MAApB,CAA2B,KAA3B;AACD,OAFD;;AAIA;AACA;AACA,UAAI,CAAC,QAAQ,QAAR,CAAiB,cAAjB,CAAL,EAAuC;AACrC,mBAAW,KAAX,EAAkB,UAAS,KAAT,EAAgB;AAChC;AACA;AACA;AACA;AACA,cAAI,UAAU,SAAS,0DAA0D,SAA1D,GAAsE,QAA/E,EAAyF,KAAzF,CAAd;;AAEA;AACA;AACA,kBAAQ,QAAR,CAAiB,YAAW;AAC1B;AACA;AACA;AACA;AACA,uBAAW,OAAX,EAAoB,MAApB,CAA2B,KAA3B;AACD,WAND;;AAQA;AACA;AACA,oBAAU,KAAV,EAAiB,OAAjB,EAA0B,OAA1B;AACD,SApBD;AAqBD;AACF;AA9DI,GAAP;AAgED;;AAED,WAAW,UAAX,CAAsB,SAAtB,GAAkC,QAAQ,MAAR,CAAe,+BAAf,CAAlC","file":"subheader-compiled.js","sourcesContent":["/*!\n * Angular Material Design\n * https://github.com/angular/material\n * @license MIT\n * v1.1.1-master-f7ecb4f\n */\ngoog.provide('ngmaterial.components.subheader');\ngoog.require('ngmaterial.components.sticky');\ngoog.require('ngmaterial.core');\n/**\n * @ngdoc module\n * @name material.components.subheader\n * @description\n * SubHeader module\n *\n *  Subheaders are special list tiles that delineate distinct sections of a\n *  list or grid list and are typically related to the current filtering or\n *  sorting criteria. Subheader tiles are either displayed inline with tiles or\n *  can be associated with content, for example, in an adjacent column.\n *\n *  Upon scrolling, subheaders remain pinned to the top of the screen and remain\n *  pinned until pushed on or off screen by the next subheader. @see [Material\n *  Design Specifications](https://www.google.com/design/spec/components/subheaders.html)\n *\n *  > To improve the visual grouping of content, use the system color for your subheaders.\n *\n */\nMdSubheaderDirective['$inject'] = [\"$mdSticky\", \"$compile\", \"$mdTheming\", \"$mdUtil\", \"$mdAria\"];\nangular\n  .module('material.components.subheader', [\n    'material.core',\n    'material.components.sticky'\n  ])\n  .directive('mdSubheader', MdSubheaderDirective);\n\n/**\n * @ngdoc directive\n * @name mdSubheader\n * @module material.components.subheader\n *\n * @restrict E\n *\n * @description\n * The `md-subheader` directive creates a sticky subheader for a section.\n *\n * Developers are able to disable the stickiness of the subheader by using the following markup\n *\n * <hljs lang=\"html\">\n *   <md-subheader class=\"md-no-sticky\">Not Sticky</md-subheader>\n * </hljs>\n *\n * ### Notes\n * - The `md-subheader` directive uses the <a ng-href=\"api/service/$mdSticky\">$mdSticky</a> service\n * to make the subheader sticky.\n *\n * > Whenever the current browser doesn't support stickiness natively, the subheader\n * will be compiled twice to create a sticky clone of the subheader.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-subheader>Online Friends</md-subheader>\n * </hljs>\n */\n\nfunction MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil, $mdAria) {\n  return {\n    restrict: 'E',\n    replace: true,\n    transclude: true,\n    template: (\n    '<div class=\"md-subheader _md\">' +\n    '  <div class=\"md-subheader-inner\">' +\n    '    <div class=\"md-subheader-content\"></div>' +\n    '  </div>' +\n    '</div>'\n    ),\n    link: function postLink(scope, element, attr, controllers, transclude) {\n      $mdTheming(element);\n      element.addClass('_md');\n\n      // Remove the ngRepeat attribute from the root element, because we don't want to compile\n      // the ngRepeat for the sticky clone again.\n      $mdUtil.prefixer().removeAttribute(element, 'ng-repeat');\n\n      var outerHTML = element[0].outerHTML;\n\n      function getContent(el) {\n        return angular.element(el[0].querySelector('.md-subheader-content'));\n      }\n\n      // Set the ARIA attributes on the original element since it keeps it's original place in\n      // the DOM, whereas the clones are in reverse order. Should be done after the outerHTML,\n      // in order to avoid having multiple element be marked as headers.\n      attr.$set('role', 'heading');\n      $mdAria.expect(element, 'aria-level', '2');\n\n      // Transclude the user-given contents of the subheader\n      // the conventional way.\n      transclude(scope, function(clone) {\n        getContent(element).append(clone);\n      });\n\n      // Create another clone, that uses the outer and inner contents\n      // of the element, that will be 'stickied' as the user scrolls.\n      if (!element.hasClass('md-no-sticky')) {\n        transclude(scope, function(clone) {\n          // If the user adds an ng-if or ng-repeat directly to the md-subheader element, the\n          // compiled clone below will only be a comment tag (since they replace their elements with\n          // a comment) which cannot be properly passed to the $mdSticky; so we wrap it in our own\n          // DIV to ensure we have something $mdSticky can use\n          var wrapper = $compile('<div class=\"md-subheader-wrapper\" aria-hidden=\"true\">' + outerHTML + '</div>')(scope);\n\n          // Delay initialization until after any `ng-if`/`ng-repeat`/etc has finished before\n          // attempting to create the clone\n          $mdUtil.nextTick(function() {\n            // Append our transcluded clone into the wrapper.\n            // We don't have to recompile the element again, because the clone is already\n            // compiled in it's transclusion scope. If we recompile the outerHTML of the new clone, we would lose\n            // our ngIf's and other previous registered bindings / properties.\n            getContent(wrapper).append(clone);\n          });\n\n          // Make the element sticky and provide the stickyClone our self, to avoid recompilation of the subheader\n          // element.\n          $mdSticky(scope, element, wrapper);\n        });\n      }\n    }\n  };\n}\n\nngmaterial.components.subheader = angular.module(\"material.components.subheader\");"]}