{"version":3,"sources":["colors.js"],"names":[],"mappings":"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","file":"colors-compiled.js","sourcesContent":["/*!\n * Angular Material Design\n * https://github.com/angular/material\n * @license MIT\n * v1.1.1-master-f7ecb4f\n */\ngoog.provide('ngmaterial.components.colors');\ngoog.require('ngmaterial.core');\n(function () {\n  \"use strict\";\n\n  /**\n   *  Use a RegExp to check if the `md-colors=\"<expression>\"` is static string\n   *  or one that should be observed and dynamically interpolated.\n   */\n  MdColorsDirective['$inject'] = [\"$mdColors\", \"$mdUtil\", \"$log\", \"$parse\"];\n  MdColorsService['$inject'] = [\"$mdTheming\", \"$mdUtil\", \"$log\"];\n  var STATIC_COLOR_EXPRESSION = /^{((\\s|,)*?[\"'a-zA-Z-]+?\\s*?:\\s*?('|\")[a-zA-Z0-9-.]*('|\"))+\\s*}$/;\n  var colorPalettes = null;\n\n  /**\n   * @ngdoc module\n   * @name material.components.colors\n   *\n   * @description\n   * Define $mdColors service and a `md-colors=\"\"` attribute directive\n   */\n  angular\n    .module('material.components.colors', ['material.core'])\n    .directive('mdColors', MdColorsDirective)\n    .service('$mdColors', MdColorsService);\n\n  /**\n   * @ngdoc service\n   * @name $mdColors\n   * @module material.components.colors\n   *\n   * @description\n   * With only defining themes, one couldn't get non ngMaterial elements colored with Material colors,\n   * `$mdColors` service is used by the md-color directive to convert the 1..n color expressions to RGBA values and will apply\n   * those values to element as CSS property values.\n   *\n   *  @usage\n   *  <hljs lang=\"js\">\n   *    angular.controller('myCtrl', function ($mdColors) {\n   *      var color = $mdColors.getThemeColor('myTheme-red-200-0.5');\n   *      ...\n   *    });\n   *  </hljs>\n   *\n   */\n  function MdColorsService($mdTheming, $mdUtil, $log) {\n    colorPalettes = colorPalettes || Object.keys($mdTheming.PALETTES);\n\n    // Publish service instance\n    return {\n      applyThemeColors: applyThemeColors,\n      getThemeColor: getThemeColor,\n      hasTheme: hasTheme\n    };\n\n    // ********************************************\n    // Internal Methods\n    // ********************************************\n\n    /**\n     * @ngdoc method\n     * @name $mdColors#applyThemeColors\n     *\n     * @description\n     * Gets a color json object, keys are css properties and values are string of the wanted color\n     * Then calculate the rgba() values based on the theme color parts\n     *\n     * @param {DOMElement} element the element to apply the styles on.\n     * @param {object} colorExpression json object, keys are css properties and values are string of the wanted color,\n     * for example: `{color: 'red-A200-0.3'}`.\n     *\n     * @usage\n     * <hljs lang=\"js\">\n     *   app.directive('myDirective', function($mdColors) {\n     *     return {\n     *       ...\n     *       link: function (scope, elem) {\n     *         $mdColors.applyThemeColors(elem, {color: 'red'});\n     *       }\n     *    }\n     *   });\n     * </hljs>\n     */\n    function applyThemeColors(element, colorExpression) {\n      try {\n        if (colorExpression) {\n          // Assign the calculate RGBA color values directly as inline CSS\n          element.css(interpolateColors(colorExpression));\n        }\n      } catch (e) {\n        $log.error(e.message);\n      }\n\n    }\n\n    /**\n     * @ngdoc method\n     * @name $mdColors#getThemeColor\n     *\n     * @description\n     * Get parsed color from expression\n     *\n     * @param {string} expression string of a color expression (for instance `'red-700-0.8'`)\n     *\n     * @returns {string} a css color expression (for instance `rgba(211, 47, 47, 0.8)`)\n     *\n     * @usage\n     *  <hljs lang=\"js\">\n     *    angular.controller('myCtrl', function ($mdColors) {\n     *      var color = $mdColors.getThemeColor('myTheme-red-200-0.5');\n     *      ...\n     *    });\n     *  </hljs>\n     */\n    function getThemeColor(expression) {\n      var color = extractColorOptions(expression);\n\n      return parseColor(color);\n    }\n\n    /**\n     * Return the parsed color\n     * @param color hashmap of color definitions\n     * @param contrast whether use contrast color for foreground\n     * @returns rgba color string\n     */\n    function parseColor(color, contrast) {\n      contrast = contrast || false;\n      var rgbValues = $mdTheming.PALETTES[color.palette][color.hue];\n\n      rgbValues = contrast ? rgbValues.contrast : rgbValues.value;\n\n      return $mdUtil.supplant('rgba({0}, {1}, {2}, {3})',\n        [rgbValues[0], rgbValues[1], rgbValues[2], rgbValues[3] || color.opacity]\n      );\n    }\n\n    /**\n     * Convert the color expression into an object with scope-interpolated values\n     * Then calculate the rgba() values based on the theme color parts\n     *\n     * @results Hashmap of CSS properties with associated `rgba( )` string vales\n     *\n     *\n     */\n    function interpolateColors(themeColors) {\n      var rgbColors = {};\n\n      var hasColorProperty = themeColors.hasOwnProperty('color');\n\n      angular.forEach(themeColors, function (value, key) {\n        var color = extractColorOptions(value);\n        var hasBackground = key.indexOf('background') > -1;\n\n        rgbColors[key] = parseColor(color);\n        if (hasBackground && !hasColorProperty) {\n          rgbColors.color = parseColor(color, true);\n        }\n      });\n\n      return rgbColors;\n    }\n\n    /**\n     * Check if expression has defined theme\n     * e.g.\n     * 'myTheme-primary' => true\n     * 'red-800' => false\n     */\n    function hasTheme(expression) {\n      return angular.isDefined($mdTheming.THEMES[expression.split('-')[0]]);\n    }\n\n    /**\n     * For the evaluated expression, extract the color parts into a hash map\n     */\n    function extractColorOptions(expression) {\n      var parts = expression.split('-');\n      var hasTheme = angular.isDefined($mdTheming.THEMES[parts[0]]);\n      var theme = hasTheme ? parts.splice(0, 1)[0] : $mdTheming.defaultTheme();\n\n      return {\n        theme: theme,\n        palette: extractPalette(parts, theme),\n        hue: extractHue(parts, theme),\n        opacity: parts[2] || 1\n      };\n    }\n\n    /**\n     * Calculate the theme palette name\n     */\n    function extractPalette(parts, theme) {\n      // If the next section is one of the palettes we assume it's a two word palette\n      // Two word palette can be also written in camelCase, forming camelCase to dash-case\n\n      var isTwoWord = parts.length > 1 && colorPalettes.indexOf(parts[1]) !== -1;\n      var palette = parts[0].replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n      if (isTwoWord)  palette = parts[0] + '-' + parts.splice(1, 1);\n\n      if (colorPalettes.indexOf(palette) === -1) {\n        // If the palette is not in the palette list it's one of primary/accent/warn/background\n        var scheme = $mdTheming.THEMES[theme].colors[palette];\n        if (!scheme) {\n          throw new Error($mdUtil.supplant('mdColors: couldn\\'t find \\'{palette}\\' in the palettes.', {palette: palette}));\n        }\n        palette = scheme.name;\n      }\n\n      return palette;\n    }\n\n    function extractHue(parts, theme) {\n      var themeColors = $mdTheming.THEMES[theme].colors;\n\n      if (parts[1] === 'hue') {\n        var hueNumber = parseInt(parts.splice(2, 1)[0], 10);\n\n        if (hueNumber < 1 || hueNumber > 3) {\n          throw new Error($mdUtil.supplant('mdColors: \\'hue-{hueNumber}\\' is not a valid hue, can be only \\'hue-1\\', \\'hue-2\\' and \\'hue-3\\'', {hueNumber: hueNumber}));\n        }\n        parts[1] = 'hue-' + hueNumber;\n\n        if (!(parts[0] in themeColors)) {\n          throw new Error($mdUtil.supplant('mdColors: \\'hue-x\\' can only be used with [{availableThemes}], but was used with \\'{usedTheme}\\'', {\n            availableThemes: Object.keys(themeColors).join(', '),\n            usedTheme: parts[0]\n          }));\n        }\n\n        return themeColors[parts[0]].hues[parts[1]];\n      }\n\n      return parts[1] || themeColors[parts[0] in themeColors ? parts[0] : 'primary'].hues['default'];\n    }\n  }\n\n  /**\n   * @ngdoc directive\n   * @name mdColors\n   * @module material.components.colors\n   *\n   * @restrict A\n   *\n   * @description\n   * `mdColors` directive will apply the theme-based color expression as RGBA CSS style values.\n   *\n   *   The format will be similar to our color defining in the scss files:\n   *\n   *   ## `[?theme]-[palette]-[?hue]-[?opacity]`\n   *   - [theme]    - default value is the default theme\n   *   - [palette]  - can be either palette name or primary/accent/warn/background\n   *   - [hue]      - default is 500 (hue-x can be used with primary/accent/warn/background)\n   *   - [opacity]  - default is 1\n   *\n   *   > `?` indicates optional parameter\n   *\n   * @usage\n   * <hljs lang=\"html\">\n   *   <div md-colors=\"{background: 'myTheme-accent-900-0.43'}\">\n   *     <div md-colors=\"{color: 'red-A100', 'border-color': 'primary-600'}\">\n   *       <span>Color demo</span>\n   *     </div>\n   *   </div>\n   * </hljs>\n   *\n   * `mdColors` directive will automatically watch for changes in the expression if it recognizes an interpolation\n   * expression or a function. For performance options, you can use `::` prefix to the `md-colors` expression\n   * to indicate a one-time data binding.\n   * <hljs lang=\"html\">\n   *   <md-card md-colors=\"::{background: '{{theme}}-primary-700'}\">\n   *   </md-card>\n   * </hljs>\n   *\n   */\n  function MdColorsDirective($mdColors, $mdUtil, $log, $parse) {\n    return {\n      restrict: 'A',\n      require: ['^?mdTheme'],\n      compile: function (tElem, tAttrs) {\n        var shouldWatch = shouldColorsWatch();\n\n        return function (scope, element, attrs, ctrl) {\n          var mdThemeController = ctrl[0];\n\n          var lastColors = {};\n\n          var parseColors = function (theme) {\n            if (typeof theme !== 'string') {\n              theme = '';\n            }\n\n            if (!attrs.mdColors) {\n              attrs.mdColors = '{}';\n            }\n\n            /**\n             * Json.parse() does not work because the keys are not quoted;\n             * use $parse to convert to a hash map\n             */\n            var colors = $parse(attrs.mdColors)(scope);\n\n            /**\n             * If mdTheme is defined up the DOM tree\n             * we add mdTheme theme to colors who doesn't specified a theme\n             *\n             * # example\n             * <hljs lang=\"html\">\n             *   <div md-theme=\"myTheme\">\n             *     <div md-colors=\"{background: 'primary-600'}\">\n             *       <span md-colors=\"{background: 'mySecondTheme-accent-200'}\">Color demo</span>\n             *     </div>\n             *   </div>\n             * </hljs>\n             *\n             * 'primary-600' will be 'myTheme-primary-600',\n             * but 'mySecondTheme-accent-200' will stay the same cause it has a theme prefix\n             */\n            if (mdThemeController) {\n              Object.keys(colors).forEach(function (prop) {\n                var color = colors[prop];\n                if (!$mdColors.hasTheme(color)) {\n                  colors[prop] = (theme || mdThemeController.$mdTheme) + '-' + color;\n                }\n              });\n            }\n\n            cleanElement(colors);\n\n            return colors;\n          };\n\n          var cleanElement = function (colors) {\n            if (!angular.equals(colors, lastColors)) {\n              var keys = Object.keys(lastColors);\n\n              if (lastColors.background && !keys.color) {\n                keys.push('color');\n              }\n\n              keys.forEach(function (key) {\n                element.css(key, '');\n              });\n            }\n\n            lastColors = colors;\n          };\n\n          /**\n           * Registering for mgTheme changes and asking mdTheme controller run our callback whenever a theme changes\n           */\n          var unregisterChanges = angular.noop;\n\n          if (mdThemeController) {\n            unregisterChanges = mdThemeController.registerChanges(function (theme) {\n              $mdColors.applyThemeColors(element, parseColors(theme));\n            });\n          }\n\n          scope.$on('$destroy', function () {\n            unregisterChanges();\n          });\n\n          try {\n            if (shouldWatch) {\n              scope.$watch(parseColors, angular.bind(this,\n                $mdColors.applyThemeColors, element\n              ), true);\n            }\n            else {\n              $mdColors.applyThemeColors(element, parseColors());\n            }\n\n          }\n          catch (e) {\n            $log.error(e.message);\n          }\n\n        };\n\n        function shouldColorsWatch() {\n          // Simulate 1x binding and mark mdColorsWatch == false\n          var rawColorExpression = tAttrs.mdColors;\n          var bindOnce = rawColorExpression.indexOf('::') > -1;\n          var isStatic = bindOnce ? true : STATIC_COLOR_EXPRESSION.test(tAttrs.mdColors);\n\n          // Remove it for the postLink...\n          tAttrs.mdColors = rawColorExpression.replace('::', '');\n\n          var hasWatchAttr = angular.isDefined(tAttrs.mdColorsWatch);\n\n          return (bindOnce || isStatic) ? false :\n            hasWatchAttr ? $mdUtil.parseAttributeBoolean(tAttrs.mdColorsWatch) : true;\n        }\n      }\n    };\n\n  }\n\n\n})();\n\nngmaterial.components.colors = angular.module(\"material.components.colors\");"]}